

module chi(
input clk,
input rst,
input [1599:0] in,
input [5:0]addr,
output reg [1599:0] out
);
  reg [63:0] Y[4:0][4:0];
  reg [63:0] A[4:0][4:0];

reg [63:0] rc_out;

always @(addr) begin
    case (addr)
        5'd0:  rc_out <= 64'h0000000000000001;
        5'd1:  rc_out <= 64'h0000000000008082;
        5'd2:  rc_out <= 64'h800000000000808A;
        5'd3:  rc_out <= 64'h8000000080008000;
        5'd4:  rc_out <= 64'h000000000000808B;
        5'd5:  rc_out <= 64'h0000000080000001;
        5'd6:  rc_out <= 64'h8000000080008081;
        5'd7:  rc_out <= 64'h8000000000008009;
        5'd8:  rc_out <= 64'h000000000000008A;
        5'd9:  rc_out <= 64'h0000000000000088;
        5'd10: rc_out <= 64'h0000000080008009;
        5'd11: rc_out <= 64'h000000008000000A;
        5'd12: rc_out <= 64'h000000008000808B;
        5'd13: rc_out <= 64'h800000000000008B;
        5'd14: rc_out <= 64'h8000000000008089;
        5'd15: rc_out <= 64'h8000000000008003;
        5'd16: rc_out <= 64'h8000000000008002;
        5'd17: rc_out <= 64'h8000000000000080;
        5'd18: rc_out <= 64'h000000000000800A;
        5'd19: rc_out <= 64'h800000008000000A;
        5'd20: rc_out <= 64'h8000000080008081;
        5'd21: rc_out <= 64'h8000000000008080;
        5'd22: rc_out <= 64'h0000000080000001;
        5'd23: rc_out <= 64'h8000000080008008;
        default: rc_out <= 64'h0000000000000000;
    endcase
end

always@(posedge clk or posedge rst) begin
if(rst)begin out<=0;
end
else begin
 out<={ A[0][0]^rc_out, A[0][1], A[0][2], A[0][3], A[0][4],
A[1][0], A[1][1], A[1][2], A[1][3], A[1][4],
A[2][0], A[2][1], A[2][2], A[2][3], A[2][4],
A[3][0], A[3][1], A[3][2], A[3][3], A[3][4],
A[4][0], A[4][1], A[4][2], A[4][3], A[4][4]
 };
  end
end

always@(*) begin
  {Y[0][0], Y[0][1], Y[0][2], Y[0][3], Y[0][4],
Y[1][0], Y[1][1], Y[1][2], Y[1][3], Y[1][4],
Y[2][0], Y[2][1], Y[2][2], Y[2][3], Y[2][4],
Y[3][0], Y[3][1], Y[3][2], Y[3][3], Y[3][4],
Y[4][0], Y[4][1], Y[4][2], Y[4][3], Y[4][4]} = in;
 // A[x][y]=Y[x][y]âŠ•(âˆ¼Y[(x+1)mod5][y]&Y[(x+2)mod5][y])
 //0-2 rev, 4-3 rev 
A[0][0] = Y[0][0] ^ (~Y[1][0] & Y[2][0]);
A[0][1] = Y[0][1] ^ (~Y[1][1] & Y[2][1]);
A[0][2] = Y[0][2] ^ (~Y[1][2] & Y[2][2]);
A[0][3] = Y[0][3] ^ (~Y[1][3] & Y[2][3]);
A[0][4] = Y[0][4] ^ (~Y[1][4] & Y[2][4]);

A[1][0] = Y[1][0] ^ (~Y[2][0] & Y[3][0]);
A[1][1] = Y[1][1] ^ (~Y[2][1] & Y[3][1]);
A[1][2] = Y[1][2] ^ (~Y[2][2] & Y[3][2]);
A[1][3] = Y[1][3] ^ (~Y[2][3] & Y[3][3]);
A[1][4] = Y[1][4] ^ (~Y[2][4] & Y[3][4]);

A[2][0] = Y[2][0] ^ (~Y[3][0] & Y[4][0]);
A[2][1] = Y[2][1] ^ (~Y[3][1] & Y[4][1]);
A[2][2] = Y[2][2] ^ (~Y[3][2] & Y[4][2]);
A[2][3] = Y[2][3] ^ (~Y[3][3] & Y[4][3]);
A[2][4] = Y[2][4] ^ (~Y[3][4] & Y[4][4]);

A[3][0] = Y[3][0] ^ (~Y[4][0] & Y[0][0]);
A[3][1] = Y[3][1] ^ (~Y[4][1] & Y[0][1]);
A[3][2] = Y[3][2] ^ (~Y[4][2] & Y[0][2]);
A[3][3] = Y[3][3] ^ (~Y[4][3] & Y[0][3]);
A[3][4] = Y[3][4] ^ (~Y[4][4] & Y[0][4]);

A[4][0] = Y[4][0] ^ (~Y[0][0] & Y[1][0]);
A[4][1] = Y[4][1] ^ (~Y[0][1] & Y[1][1]);
A[4][2] = Y[4][2] ^ (~Y[0][2] & Y[1][2]);
A[4][3] = Y[4][3] ^ (~Y[0][3] & Y[1][3]);
A[4][4] = Y[4][4] ^ (~Y[0][4] & Y[1][4]);
  
end  
endmodule